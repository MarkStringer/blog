# Chapter 3 
# Some and All in the Agile Manifesto 
>"We will glorify war - the world's only hygiene - militarism, patriotism, the destructive gesture of freedom-bringers, beautiful ideas worth dying for" 

*Filippo Tommaso Marinetti - The Futurist Manifesto* 

>We are uncovering better ways of developing 
>software by doing it and helping others do it. 
>Through this work we have come to value: 
	>Individuals and interactions over processes and tools 
	>Working software over comprehensive documentation 
	>Customer collaboration over contract negotiation 
	>Responding to change over following a plan 
>That is, while there is value in the items on 
>the right, we value the items on the left more. 
*The Manifesto for Agile Software Development* 

### The Agile Manifesto 
As we can see from the brief quotation of the Futurist manifesto, some manifestos state a position strongly and powerfully. They are a statement of strongly held beliefs and ideas. They are a call to action. 

But the Agile manifesto starts out like this: 

"We are uncovering better ways of developing software by doing it and helping others do it." 

Compared to many other manifestos the Agile manifesto seems unsure of itself. Notice the ways that are being uncovered are not necessarily the *best* ways. They are merely better ways. They aren't even completely known, they are being discovered. In its very first line the Agile manifesto emphasises the importance of *some* rather than *all*. 

The Agile manifesto then moves on to talk about four things that its signatories have "come to value." These are all worth looking at in detail. 

### individuals and interactions over processes and tools 

This is a doubly uncertain statement. It says that individuals and interactions are to be valued over processes and tools. Note that it *doesn't* say that there's *no* value in processes and tools. It also puts forward the idea of software development as an ongoing conversation rather than something that can be captured completely in a document. 

>Programming is a social activity

*Robert C. Martin*

But what this means for software development is only really clear if it is set against the background of the waterfall thinking which was prevalent at the time and which we talked about in Chapter 2.

If something is open to discussion, it is not finalised, it is not complete and the entire appeal of a waterfall approach relies on completeness. Many of the approaches to waterfall that were being used in the mid-nineties, if they didn't say it out loud, at least suggested in their marketing, that if you followed their processes you were almost guaranteed to succeed. The manifesto is stressing the incompleteness of a continuing conversation (some) over the completeness of a conversation being over and complete (all).

### working software over comprehensive documentation 

This is worded gently but, in its own way, it's dynamite. Again, the way this is phrased is not an absolute statement (get *something* working rather than documenting *everything*). But there *is* something absolute about working software, and the Agile manifesto values it. What does that mean exactly? security tested? acceptance tested? performance tested? available on a live site? For the people deeply involved in the development and testing of software this might be a lively debate. But on a more basic level, working software is an absolute requirement. There's a piece of software, somewhere on some machine that will either run and do something, or it won't. It either works or it doesn't. 

The process of getting *anything* to work *at all* is threatening to a project and its sponsors for one reason: when you try to get something to work, especially in software development, there's a chance you might not succeed. What if the very first bit of a project that you try to get working doesn't work? What does that mean for the big idea of the whole project? What would that mean for your reputation? If you were a customer who was depending on this project working to deliver on other promises?  If you were a project manager whose reputation is bound up with project delivery? Or a developer who might have to look for other work if the project folds? 

Trying to get something working and failing is a dangerous business. In fact the only thing that's potentially *more* dangerous to a project is, well, *getting* something working. Why on earth would getting some software to work be threatening? Maybe now it’s time for another story.  

>Any sufficiently advanced technology is indistinguishable from magic.
*Arthur C. Clarke*

Arthur C. Clarke, is completely right about this. People treat technology that works as magical. They way they treat workking software is completely different from the way they treat a document containing the specifications of that software.

I was working on a fraud detection project for a big retail bank. I was supposed to be the  “Agile Coach”. But all the time that I'd been working on it, it had been a good, old-fashioned waterfall project. For six months the project had been in the requirements-gathering phase.  Often, trying to earn my keep as an Agile coach, I suggested that the best thing to do would be to start doing some actual development: “Working software over detailed documentation.” But I was told that that could only be done when the project was sufficiently detailed it could be estimated within “plus or minus ten percent.” When I asked what we needed to do to satisfy ourselves that we’d reached this level of certainty, I found that whoever I was talking to suddenly remembered that they had a dental appointment, or that they needed to rush off and pick up their kids from school. Even the ones that I knew didn’t have any kids. 

Then, suddenly, requirements gathering stopped.  Not because everybody was now certain how much development would cost, but for a far more powerful reason. The budget for analysis ran out. 

And so, with the budget for analysis exhausted, the team started to do development in an Agile and iterative fashion, using an Agile method called Scrum (we'll talk about Scrum a lot more in the next chapter).  

We planned a fortnight's worth of work at a planning meeting. Not all of the work.  Just some. The development team worked on it for a fortnight. Every morning we had a stand-up meeting where we talked about the work that we'd done the day before and the work that we were going to do. Again, not even all of the work for the fortnight, just the small part that we were currently working on. Then at the end of the two weeks we had a “Show and Tell” where we demonstrated some “working software”. We demonstrated this small bit of work that we'd done to the people who represented the customer, the product owners (in Scrum there's only supposed to be one product owner, but this was a far from perfect Scrum set up, so there were three). 

Guess what? Fraud detection is a really important function in a retail bank. There were lots of stakeholders interested in seeing how the project was coming along. The Show and Tell wasn't just a packed meeting room, but also people dialling in and sharing the presentation screen: in India where some of the development was happening; in Scotland, Northern Ireland and the South East of England where people who worked with the current system really wanted to know what the new one would look like. 

And so, one of the product owners talked through some working software: the very first screen of the new fraud detection system. And in the room and online, on what had been a very noisy conference call, there was a very awkward silence. 

“I thought we'd agreed that the workflow would be organised by account holder rather than account number,” somebody said eventually. 

I was in the room with the lead business analyst (BA) who frowned “No, I don't remember that being agreed anywhere.” On the conference call there were gasps, sighs and sharp intakes of breath. “See the problem is...” continued the same voice “...fraud detection only really makes sense to us if we can look at all of the accounts held by one individual, rather than just looking at one account.” 

Up to this point, millions had been spent on business analysis for this project. Months if not years, had been spent on it. And remember, so much of that time and money was spent in the hope of getting a complete specification, a specification that captured *all* of the requirements “within plus or minus ten percent.” Although nobody who could plausibly claim to have either teeth or children would ever admit to knowing what that meant. 

But after less than ten minutes of letting the people who would actually use it look at the *working software*, it became obvious that a lot of that work would either need to be redone, or thrown away entirely. 

This is what makes the Agile manifesto's emphasis on working software so powerful, but it's also what makes it so threatening and dangerous. No manager, no stakeholder, wants to find out that they've spent huge amounts of time and money on the wrong thing. 

### customer collaboration over contract negotiation
>Grouch: That's in every contract. That's, that's what they call a 'sanity clause'. 
>Chico: Ha ha ha ha ha! You can't fool me! There ain't no Sanity Clause! 

Again this value emphasises the incomplete, partial, conversational nature of software development. Just as there is no requirements document that can capture *all* the details.  There is no *contract* that can capture all of the eventualities and guarantee, either valuable software for the client, or a reasonable margin for the developers. The whole process needs to be a continuing collaboration.

But remember, this isn't to say that software development projects don't need contracts. Look carefully at what the manifesto actually says. It says that it values customer collaboration over contract negotiation. People react to this line in the manifesto in some strange ways. In fact what they do is to react to the suggestion of partial solutions *absolutely*.

For example, one way that people react is to say “There's no way that we can do business without a contract.” This is to hear the idea that's suggested in the manifesto - “contracts aren't everything” and interpret absolutely as “there should be no contracts.” Which is simply not what it says.

Another way that people react to the suggestion of an Agile approach is to say “OK, you need to tell me exactly what an Agile contract will look like that will absolutely ensure that this project will be a success.” Yes, this is crazy, but variations of this demand are quite common. And this might be a time to remind ourselves of the title of this book: “Delivering the Impossible”. Well, one way to do better at delivering the impossible is notice when you're being asked for it.

But, people might ask, we can at least capture in the contract exactly what we want the software to do can't we? Well, think about this for a minute. If the contract *could* capture exactly what the software should do, it would be as good as a detailed specification. Didn’t we just talked in the previous section about the difficults of getting detailed documentation?

But none of this really address the real reason that it's not worth the time to try to get a perfectly-crafted contract and a minutely detailed specification. The real reason you need to keep talking to your customer is because the situation that you're drafting a contract for isn't the situation you'll find yourself in and the specification of what you think you want now isn't anywhere near what you'll ending up wanting, or finally get.  Why? Because things change.

### responding to change over following a plan 

>”Everything changes and nothing stays the same and you cannot step twice into 
the same stream ”

*Plato quoting Heraclitus*

Let's go back to that story of the fraud detection project and that awkward conversation that happened just a few minutes after looking at some working software. The way I told it, and the way it played out, was that people who currently did fraud detection, the people who were going to use it, had known all along that the system would only make sense if transactions were grouped by individuals rather than by account. But what if that wasn't true? 

What if the users had only started to realise that this was a really important requirement once they'd actually seen the screens? What if that was they way they used to think about things before they merged with the fraud department of another bank and they noticed that they way that the new guys did things was much better? What if they'd just recently heard that new regulations would require that fraud transactions had to be dealt with in the way that they were suggesting? What if their understanding of what they wanted had *changed* as a result of them thinking about what they wanted, or as a result of looking at what they'd asked for.

In some ways this is the most revolutionary of the four Agile values in the manifesto. By admitting that change is an inevitable part of the software development process, we're posing a threat to the very idea of what the projects are, and what delivering them successfully would look like. 

Highlighting that responding to change is the business that we're in, rather than delivering on a plan attacks the whole idea of a project as being merely a missing peg on the peg board. 

When we think of project management as the management of change it becomes more obvious that the empty slot in the peg board could indicate *anything but 3* rather than just a 3-shaped whole that still just happens to need to be filled. 

## So What did We Learn from looking at the Agile Manifesto

The Agile manifesto gets it's power from doing the opposite of what's expected of a manifesto, it suggests that to *some* degree we try to do *some* of *some* things.

We've seen that taking these suggestions seriously has powerful implications for how software development gets done. But we've also seen that just the act of suggesting “some” rather than “all,” partial solutions rather than total ones, can result in some strange behaviour.

What the Agile manifesto *doesn't* do, and how could it in 93 words, is give any good ideas about what we might do to make this actually happen in software developent.

For that we need a method that essentially tells us that we need to keep doing *some* *all* of the time. And by far the most successful approach to that is a method called Scrum which we'll deal with in the next chapter. 

